{"cells":[{"cell_type":"markdown","source":["## Mount drive & import"],"metadata":{"id":"H3eN0oaUUbB-"}},{"cell_type":"code","execution_count":4,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":3953,"status":"ok","timestamp":1666341574222,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"},"user_tz":-540},"id":"XltI_t_kUGvD","outputId":"5b9da2a8-b686-493f-cf7d-3a02364d18cd"},"outputs":[{"output_type":"stream","name":"stdout","text":["Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n","[Errno 2] No such file or directory: 'drive/MyDrive/IITP/sohyun/TimeSeriesAnomaly/data/modify'\n","/content/drive/.shortcut-targets-by-id/1j1N0u5t0l99N_wfSd5UZvnhugzn5g_NC/TimeSeriesAnomaly/data/modify\n"]}],"source":["from google.colab import drive\n","# drive.mount('/content/drive/MyDrive/IITP/sohyun/creditcard_prediction/data')\n","drive.mount('/content/drive')\n","\n","%cd drive/MyDrive/IITP/sohyun/TimeSeriesAnomaly/data/modify"]},{"cell_type":"code","source":["!pip install wandb -qqq\n","import wandb\n","wandb.login()"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"xJdGzqsPqom5","executionInfo":{"status":"ok","timestamp":1666341577039,"user_tz":-540,"elapsed":2819,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}},"outputId":"21db442a-917c-4c56-9879-ec7f20ea6cac"},"execution_count":5,"outputs":[{"output_type":"stream","name":"stderr","text":["\u001b[34m\u001b[1mwandb\u001b[0m: Currently logged in as: \u001b[33msohyun\u001b[0m. Use \u001b[1m`wandb login --relogin`\u001b[0m to force relogin\n"]},{"output_type":"execute_result","data":{"text/plain":["True"]},"metadata":{},"execution_count":5}]},{"cell_type":"code","execution_count":6,"metadata":{"id":"qi5fjXQLHQab","executionInfo":{"status":"ok","timestamp":1666341577039,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["# !pip install wandb -qqq\n","# import wandb\n","# wandb.login()"]},{"cell_type":"code","execution_count":7,"metadata":{"id":"gq_QRBw-_yqo","executionInfo":{"status":"ok","timestamp":1666341577039,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["import matplotlib.pyplot as plt\n","import easydict\n","from sklearn.preprocessing import StandardScaler, MinMaxScaler\n","import random\n","import pandas as pd\n","import numpy as np\n","import os\n","import torch\n","import torch.nn as nn\n","import torch.optim as optim\n","import torch.nn.functional as F\n","from torch.utils.data import Dataset, DataLoader\n","from tqdm.auto import tqdm\n","from sklearn.metrics import f1_score\n","import time\n","import math\n","\n","import seaborn as sns\n","from pylab import rcParams\n","from collections import Counter\n","from sklearn.model_selection import train_test_split\n","from sklearn import metrics\n","import copy\n","from scipy import stats\n","from sklearn.metrics import roc_curve"]},{"cell_type":"markdown","metadata":{"id":"zjoJxI3iylhf"},"source":["## Data "]},{"cell_type":"code","execution_count":8,"metadata":{"id":"yH_ixp0aWdm4","executionInfo":{"status":"ok","timestamp":1666341585590,"user_tz":-540,"elapsed":8553,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["#---# Setting path #---#\n","save_path = \"/content/drive/MyDrive/IITP/sohyun/TimeSeriesAnomaly/data/modify\"\n","\n","#---# LOAD npy file #---#\n","Fu_20_normal = np.load('Fu_20_normal.npy')\n","Fu_21_normal = np.load('Fu_21_normal.npy')\n","Fu_21_abnormal = np.load('Fu_21_abnormal.npy')\n","Fu_22_normal = np.load('Fu_22_normal.npy')\n","Fu_22_abnormal = np.load('Fu_22_abnormal.npy')\n","\n","Fu_20_normal_10 = np.load('Fu_20_normal_10.npy')\n","Fu_21_normal_10 = np.load('Fu_21_normal_10.npy')\n","Fu_21_abnormal_10 = np.load('Fu_21_abnormal_10.npy')\n","Fu_22_normal_10 = np.load('Fu_22_normal_10.npy')\n","Fu_22_abnormal_10 = np.load('Fu_22_abnormal_10.npy')\n","\n","# import sys\n","# np.set_printoptions(threshold=sys.maxsize) # print all\n","\n","#---# 확인용 #---#\n","# plt.figure(figsize=(30,5))\n","# plt.plot(Fu_22_abnormal_10)"]},{"cell_type":"markdown","source":["Dataset"],"metadata":{"id":"7d_0GAXtSXqU"}},{"cell_type":"code","execution_count":9,"metadata":{"id":"fS479XwTHmk0","executionInfo":{"status":"ok","timestamp":1666341586384,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["class MyDataset(Dataset):\n","  def __init__(self, config, mode=\"train\"):\n","    # 최종 목표 : path\n","    # self.data_path_list = data_path_list\n","    # self.data_list = [_load_data() for data_path in self.data_path_list] \n","    self.mode = mode\n","    self.config = config\n","    self.device = self.config.device\n","    self.scaler = self.config.scaler\n","    self.train_list = [Fu_22_normal_10, Fu_21_normal_10, Fu_20_normal_10]\n","    self.test_list = [Fu_22_abnormal_10]\n","    \n","    #---# scaling #---#\n","    self.scaled_train_list, self.scaled_test = self._scale()\n","    \n","    #---# sliding window & concat #---#\n","    self.slided_train_list = [self._sliding_window(data) for data in self.scaled_train_list]\n","    self.train = np.concatenate(self.slided_train_list, axis=0)\n","    \n","    #---# split #---#\n","    y = [0 for _ in range(len(self.train))]\n","    self.x_train, self.x_val, _, _ = train_test_split(self.train, y, test_size=0.2, random_state=self.config.seed)\n","    self.x_test = self._sliding_window(self.scaled_test)\n","    \n","  def __getitem__(self, index):\n","    if self.mode == \"train\":\n","      self.x = self.x_train[index]\n","    elif self.mode == \"test\":\n","      self.x = self.x_test[index]\n","    elif self.mode == \"val\":\n","      self.x = self.x_val[index]\n","    return torch.tensor(self.x, dtype=torch.float32)\n","      \n","  def __len__(self):\n","    if self.mode == \"train\":\n","      self.x = self.x_train\n","    elif self.mode == \"test\":\n","      self.x = self.x_test\n","    elif self.mode == \"val\":\n","      self.x = self.x_val\n","    return len(self.x)\n","      \n","  def _scale(self):\n","    '''\n","    input : raw data\n","    output : scaled data\n","    '''\n","    train = np.concatenate(self.train_list, axis=0)\n","    test = self.test_list[0]\n","    total = np.concatenate([train, test])\n","\n","    if self.scaler == 'standard':\n","      scaler = StandardScaler()\n","    elif self.scaler == 'minmax':\n","      scaler = MinMaxScaler()\n","    total_scaled = scaler.fit_transform(total.reshape(-1, 1)).squeeze()\n","    train_scaled = scaler.transform(train.reshape(-1,1)).squeeze()\n","    test_scaled = scaler.transform(test.reshape(-1,1)).squeeze()\n","\n","    train_list = []\n","    split_idx1, split_idx2 = len(self.train_list[0]), len(self.train_list[1]) \n","\n","    train_list.append(train_scaled[:split_idx1])\n","    train_list.append(train_scaled[split_idx1:split_idx1+split_idx2])\n","    train_list.append(train_scaled[split_idx1+split_idx2:])\n","\n","    return train_list, test_scaled\n","\n","  def _sliding_window(self, arr):\n","    start_pt = 0\n","    total_data = []\n","    \n","    while(True):\n","      if len(arr) < (start_pt + config.window_size) : break\n","      data = arr[start_pt:start_pt + config.window_size]\n","      start_pt += config.stride\n","      total_data.append(data)\n","\n","    return np.array(total_data)"]},{"cell_type":"markdown","source":["## Functions"],"metadata":{"id":"pFXdkFGgSg5M"}},{"cell_type":"code","source":["from pandas.core.arrays.sparse import array\n","def seed_everything(seed: int = 42):\n","  random.seed(seed)\n","  np.random.seed(seed)\n","  os.environ[\"PYTHONHASHSEED\"] = str(seed)\n","  torch.manual_seed(seed)\n","  torch.cuda.manual_seed(seed)  # type: ignore\n","  torch.backends.cudnn.deterministic = True  # type: ignore\n","  torch.backends.cudnn.benchmark = True  # type: ignore\n","\n","def get_anomaly_time(original, prediction) : \n","  temp = np.zeros(shape=(len(original),), dtype=np.float32)\n","  # original = original.squeeze(axis = 1)\n","\n","  for i in range(len(prediction)) :\n","    if prediction[i] == 0 :\n","      temp[i*config.stride : (i*config.stride + config.window_size)] = np.nan\n","\n","    elif prediction[i] == 1 : # anomaly\n","      temp[i*config.stride : (i*config.stride + config.window_size)] = original[i*config.stride : (i*config.stride + config.window_size)]\n","\n","  return temp\n","\n","def drawing(config, pred, x) :\n","  #---# Drawing - 22 #---#\n","  plt.figure(figsize=(30,5))\n","  plt.plot(x, markersize=1)\n","  plt.plot(pred, marker='.', markersize=2, color='r', linestyle='None')\n","  \n","  #---# 실제 anomaly 값 구간 #---#\n","  a = np.linspace(62200, 65300)\n","  b = np.linspace(95600, 99300)\n","  c = np.linspace(148400, 152300)\n","\n","  if config.scaler == 'standard':\n","    # plt.fill_between(a, 0, 2000, color='green', alpha=0.3)\n","    plt.fill_between(a, -1, 4, color='green', alpha=0.5)\n","    # plt.fill_between(b, 0, 2000, color='green', alpha=0.5)\n","    plt.fill_between(b, -1, 4, color='green', alpha=0.5)\n","    # plt.fill_between(c, 0, 2000, color='green', alpha=0.5)\n","    plt.fill_between(c, -1, 4, color='green', alpha=0.5)\n","  \n","  elif config.scaler == 'minmax':\n","    plt.fill_between(a, -0.1, 1.1, color='green', alpha=0.5)\n","    plt.fill_between(b, -0.1, 1.1, color='green', alpha=0.5)\n","    plt.fill_between(c, -0.1, 1.1, color='green', alpha=0.5)\n","\n","  plt.show()\n","  plt.clf()\n","\n","def calculate(true_list, pred_list): \n","  pred_list = pred_list.dropna()\n","\n","  pred_anomaly_set = set(pred_list.index.tolist())\n","  pred_normal_set = set(range(len(true_list))) - pred_anomaly_set\n","  true_anomaly_set = set(np.where(np.array(true_list) != 0)[0].tolist())\n","  true_normal_set = set(np.where(np.array(true_list) == 0)[0].tolist())\n","\n","  recall = len(pred_anomaly_set.intersection(true_anomaly_set)) / len(true_anomaly_set)\n","  precision = len(pred_anomaly_set.intersection(true_anomaly_set)) / len(pred_anomaly_set.union(true_anomaly_set)) # len(anomaly_set.union(true_set))\n","  accuracy = (len(pred_anomaly_set.intersection(true_anomaly_set)) + len(pred_normal_set.intersection(true_normal_set))) / len(true_list) # (빨간 거 맞은거 + 파란거 맞은거) / 전체\n","  return recall, precision, accuracy\n","\n","def calculate2(true_list, pred_list):\n","  fprs, tprs, thresholds = roc_curve(true_list, pred_list)\n","  return fprs, tprs, thresholds\n","\n","def get_true_label(test_dataset):\n","  ##########################\n","  #---# true list 만들기 #---#\n","  ##########################\n","  true_label = [0 for i in range(len(test_dataset.scaled_test))] # test_scale\n","  true_label[62200:65300] = [1 for i in range(62200,65300)]\n","  true_label[95600:99300] = [1 for i in range(95600,99300)]\n","  true_label[148400:152300] = [1 for i in range(148400,152300)]\n","\n","  # true_label_sliding = sliding_window(np.array(true_label), config.window_size, config.stride)\n","  # true_label_sliding = np.expand_dims(np.array(true_label_sliding), 2) # dimension expansion\n","  return true_label\n"],"metadata":{"id":"GD_NyF6OSftq","executionInfo":{"status":"ok","timestamp":1666341586385,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"execution_count":10,"outputs":[]},{"cell_type":"markdown","source":["Reconstruction error"],"metadata":{"id":"R29OhR0YSTh0"}},{"cell_type":"code","source":["\"\"\"\n","Time Series error calculation functions.\n","\"\"\"\n","\n","import math\n","\n","import numpy as np\n","import pandas as pd\n","# from pyts.metrics import dtw\n","from scipy import integrate\n","\n","\n","def regression_errors(y, y_hat, smoothing_window=0.01, smooth=True):\n","  \"\"\"Compute an array of absolute errors comparing predictions and expected output.\n","  If smooth is True, apply EWMA to the resulting array of errors.\n","  Args:\n","    y (ndarray):\n","      Ground truth.\n","    y_hat (ndarray):\n","      Predicted values.\n","    smoothing_window (float):\n","      Optional. Size of the smoothing window, expressed as a proportion of the total\n","      length of y. If not given, 0.01 is used.\n","    smooth (bool):\n","      Optional. Indicates whether the returned errors should be smoothed with EWMA.\n","      If not given, `True` is used.\n","  Returns:\n","    ndarray:\n","      Array of errors.\n","  \"\"\"\n","  errors = np.abs(y - y_hat)[:, 0]\n","\n","  if not smooth:\n","    return errors\n","\n","  smoothing_window = int(smoothing_window * len(y))\n","\n","  return pd.Series(errors).ewm(span=smoothing_window).mean().values\n","\n","\n","def _point_wise_error(y, y_hat):\n","  \"\"\"Compute point-wise error between predicted and expected values.\n","  The computed error is calculated as the difference between predicted\n","  and expected values with a rolling smoothing factor.\n","  Args:\n","    y (ndarray):\n","      Ground truth.\n","    y_hat (ndarray):\n","      Predicted values.\n","  Returns:\n","    ndarray:\n","      An array of smoothed point-wise error.\n","  \"\"\"\n","  return abs(y - y_hat)\n","\n","\n","def _area_error(y, y_hat, score_window=10):\n","  \"\"\"Compute area error between predicted and expected values.\n","  The computed error is calculated as the area difference between predicted\n","  and expected values with a smoothing factor.\n","  Args:\n","    y (ndarray):\n","      Ground truth.\n","    y_hat (ndarray):\n","      Predicted values.\n","    score_window (int):\n","      Optional. Size of the window over which the scores are calculated.\n","      If not given, 10 is used.\n","  Returns:\n","    ndarray:\n","      An array of area error.\n","  \"\"\"\n","  smooth_y = pd.Series(y).rolling(\n","      score_window, center=True, min_periods=score_window // 2).apply(integrate.trapz)\n","  smooth_y_hat = pd.Series(y_hat).rolling(\n","      score_window, center=True, min_periods=score_window // 2).apply(integrate.trapz)\n","\n","  errors = abs(smooth_y - smooth_y_hat)\n","\n","  return errors\n","\n","\n","def _dtw_error(y, y_hat, score_window=10):\n","  \"\"\"Compute dtw error between predicted and expected values.\n","  The computed error is calculated as the dynamic time warping distance\n","  between predicted and expected values with a smoothing factor.\n","  Args:\n","    y (ndarray):\n","      Ground truth.\n","    y_hat (ndarray):\n","      Predicted values.\n","    score_window (int):\n","      Optional. Size of the window over which the scores are calculated.\n","      If not given, 10 is used.\n","  Returns:\n","    ndarray:\n","      An array of dtw error.\n","  \"\"\"\n","  length_dtw = (score_window // 2) * 2 + 1\n","  half_length_dtw = length_dtw // 2\n","\n","  # add padding\n","  y_pad = np.pad(y, (half_length_dtw, half_length_dtw),\n","                  'constant', constant_values=(0, 0))\n","  y_hat_pad = np.pad(y_hat, (half_length_dtw, half_length_dtw),\n","                  'constant', constant_values=(0, 0))\n","\n","  i = 0\n","  similarity_dtw = list()\n","  while i < len(y) - length_dtw:\n","    true_data = y_pad[i:i + length_dtw]\n","    true_data = true_data.flatten()\n","\n","    pred_data = y_hat_pad[i:i + length_dtw]\n","    pred_data = pred_data.flatten()\n","\n","    dist = dtw(true_data, pred_data)\n","    similarity_dtw.append(dist)\n","    i += 1\n","\n","  errors = ([0] * half_length_dtw + similarity_dtw +\n","            [0] * (len(y) - len(similarity_dtw) - half_length_dtw))\n","\n","  return errors\n","\n","\n","def reconstruction_errors(y, y_hat, step_size=1, score_window=10, smoothing_window=0.01,\n","                        smooth=True, rec_error_type='point'):\n","  \"\"\"Compute an array of reconstruction errors.\n","  Compute the discrepancies between the expected and the\n","  predicted values according to the reconstruction error type.\n","  Args:\n","    y (ndarray):\n","      Ground truth.\n","    y_hat (ndarray):\n","      Predicted values. Each timestamp has multiple predictions.\n","    step_size (int):\n","      Optional. Indicating the number of steps between windows in the predicted values.\n","      If not given, 1 is used.\n","    score_window (int):\n","      Optional. Size of the window over which the scores are calculated.\n","      If not given, 10 is used.\n","    smoothing_window (float or int):\n","      Optional. Size of the smoothing window, when float it is expressed as a proportion\n","      of the total length of y. If not given, 0.01 is used.\n","    smooth (bool):\n","      Optional. Indicates whether the returned errors should be smoothed.\n","      If not given, `True` is used.\n","    rec_error_type (str):\n","      Optional. Reconstruction error types ``[\"point\", \"area\", \"dtw\"]``.\n","      If not given, \"point\" is used.\n","  Returns:\n","    ndarray:\n","      Array of reconstruction errors.\n","  \"\"\"\n","  y = y.reshape(y.shape[0], -1, 1) # 추가 부분 y.shape = (932, 1000, 1)\n","  y_hat = y_hat.reshape(y_hat.shape[0], -1, 1) # 추가 부분 y_hat shape = (932, 1000, 1)\n","  \n","  if isinstance(smoothing_window, float):\n","    smoothing_window = min(math.trunc(len(y) * smoothing_window), 200) # 9\n","    # len(y) * smoothing_window = 9 (932 * 0.01)\n","\n","  true = [item[0] for item in y.reshape((y.shape[0], -1))] # 932개\n","\n","  for item in y[-1][1:]: # y[-1][1] shape : (999,1)\n","    true.extend(item) # 총 개수 1931\n","  \n","  predictions = []\n","  predictions_vs = []\n","\n","  pred_length = y_hat.shape[1] # 1000 \n","  num_errors = y_hat.shape[1] + step_size * (y_hat.shape[0] - 1) # 1931\n","\n","  for i in range(num_errors): \n","    intermediate = []\n","    for j in range(max(0, i - num_errors + pred_length), min(i + 1, pred_length)):\n","      intermediate.append(y_hat[i - j, j])\n","\n","    if intermediate:\n","      predictions.append(np.median(np.asarray(intermediate)))\n","\n","      predictions_vs.append([[\n","          np.min(np.asarray(intermediate)),\n","          np.percentile(np.asarray(intermediate), 25),\n","          np.percentile(np.asarray(intermediate), 50),\n","          np.percentile(np.asarray(intermediate), 75),\n","          np.max(np.asarray(intermediate))\n","      ]])\n","\n","  true = np.asarray(true)\n","  predictions = np.asarray(predictions)\n","  predictions_vs = np.asarray(predictions_vs)\n","\n","  # Compute reconstruction errors\n","  if rec_error_type.lower() == \"point\":\n","    errors = _point_wise_error(true, predictions)\n","\n","  elif rec_error_type.lower() == \"area\":\n","    errors = _area_error(true, predictions, score_window)\n","\n","  elif rec_error_type.lower() == \"dtw\":\n","    errors = _dtw_error(true, predictions, score_window)\n","\n","  # Apply smoothing\n","  if smooth:\n","    errors = pd.Series(errors).rolling(\n","      smoothing_window, center=True, min_periods=smoothing_window // 2).mean().values\n","\n","  return errors, predictions_vs\n","\n","###########\n","\n","def _compute_critic_score(critics, smooth_window):\n","  \"\"\"Compute an array of anomaly scores.\n","  Args:\n","      critics (ndarray):\n","          Critic values.\n","      smooth_window (int):\n","          Smooth window that will be applied to compute smooth errors.\n","  Returns:\n","      ndarray:\n","          Array of anomaly scores.\n","  \"\"\"\n","  critics = np.asarray(critics)\n","  l_quantile = np.quantile(critics, 0.25)\n","  u_quantile = np.quantile(critics, 0.75)\n","  in_range = np.logical_and(critics >= l_quantile, critics <= u_quantile)\n","  critic_mean = np.mean(critics[in_range])\n","  critic_std = np.std(critics)\n","\n","  z_scores = np.absolute((np.asarray(critics) - critic_mean) / critic_std) + 1\n","  z_scores = pd.Series(z_scores).rolling(\n","      smooth_window, center=True, min_periods=smooth_window // 2).mean().values\n","\n","  return z_scores\n","\n","\n","\n","def score_anomalies(y, y_hat, critic, index,\n","                  score_window: int = 10, critic_smooth_window: int = None,\n","                  error_smooth_window: int = None, smooth: bool = True,\n","                  rec_error_type: str = \"point\", comb: str = \"mult\",\n","                  lambda_rec: float = 0.5):\n","  \"\"\"Compute an array of anomaly scores.\n","  Anomaly scores are calculated using a combination of reconstruction error and critic score.\n","  Args:\n","      y (ndarray):\n","          Ground truth.\n","      y_hat (ndarray):\n","          Predicted values. Each timestamp has multiple predictions.\n","      index (ndarray):\n","          time index for each y (start position of the window)\n","      critic (ndarray):\n","          Critic score. Each timestamp has multiple critic scores.\n","      score_window (int):\n","          Optional. Size of the window over which the scores are calculated.\n","          If not given, 10 is used.\n","      critic_smooth_window (int):\n","          Optional. Size of window over which smoothing is applied to critic.\n","          If not given, 200 is used.\n","      error_smooth_window (int):\n","          Optional. Size of window over which smoothing is applied to error.\n","          If not given, 200 is used.\n","      smooth (bool):\n","          Optional. Indicates whether errors should be smoothed.\n","          If not given, `True` is used.\n","      rec_error_type (str):\n","          Optional. The method to compute reconstruction error. Can be one of\n","          `[\"point\", \"area\", \"dtw\"]`. If not given, 'point' is used.\n","      comb (str):\n","          Optional. How to combine critic and reconstruction error. Can be one\n","          of `[\"mult\", \"sum\", \"rec\"]`. If not given, 'mult' is used.\n","      lambda_rec (float):\n","          Optional. Used if `comb=\"sum\"` as a lambda weighted sum to combine\n","          scores. If not given, 0.5 is used.\n","  Returns:\n","      ndarray:\n","          Array of anomaly scores.\n","  \"\"\"\n","  y = y.reshape(y.shape[0], -1, 1) # 추가 부분 y.shape = (932, 1000, 1)\n","  y_hat = y_hat.reshape(y_hat.shape[0], -1, 1) # 추가 부분 y_hat shape = (932, 1000, 1)\n","\n","  critic_smooth_window = critic_smooth_window or math.trunc(y.shape[0] * 0.01)\n","  error_smooth_window = error_smooth_window or math.trunc(y.shape[0] * 0.01)\n","\n","  step_size = 1  # expected to be 1\n","\n","  true_index = index  # no offset\n","\n","  true = [item[0] for item in y.reshape((y.shape[0], -1))]\n","  for item in y[-1][1:]:\n","    true.extend(item)\n","\n","\n","  critic_extended = list()\n","  for c in critic:\n","    critic_extended.extend(np.repeat(c, y_hat.shape[1]).tolist())\n","\n","  critic_extended = np.asarray(critic_extended).reshape((-1, y_hat.shape[1]))\n","\n","  critic_kde_max = []\n","  pred_length = y_hat.shape[1]\n","  num_errors = y_hat.shape[1] + step_size * (y_hat.shape[0] - 1)\n","\n","  for i in range(num_errors):\n","    critic_intermediate = []\n","\n","    for j in range(max(0, i - num_errors + pred_length), min(i + 1, pred_length)):\n","      critic_intermediate.append(critic_extended[i - j, j])\n","\n","    if len(critic_intermediate) > 1:\n","      discr_intermediate = np.asarray(critic_intermediate)\n","      try:\n","        critic_kde_max.append(discr_intermediate[np.argmax(\n","            stats.gaussian_kde(discr_intermediate)(critic_intermediate))])\n","      except np.linalg.LinAlgError:\n","        critic_kde_max.append(np.median(discr_intermediate))\n","    else:\n","      critic_kde_max.append(np.median(np.asarray(critic_intermediate)))\n","\n","  # Compute critic scores\n","  critic_scores = _compute_critic_score(critic_kde_max, critic_smooth_window)\n","\n","  # Compute reconstruction scores\n","  rec_scores, predictions = reconstruction_errors(\n","      y, y_hat, step_size, score_window, error_smooth_window, smooth, rec_error_type)\n","\n","  rec_scores = stats.zscore(rec_scores)\n","  rec_scores = np.clip(rec_scores, a_min=0, a_max=None) + 1\n","\n","  # Combine the two scores\n","  if comb == \"mult\":\n","    final_scores = np.multiply(critic_scores, rec_scores)\n","\n","  elif comb == \"sum\":\n","    final_scores = (1 - lambda_rec) * (critic_scores - 1) + lambda_rec * (rec_scores - 1)\n","\n","  elif comb == \"rec\":\n","    final_scores = rec_scores\n","\n","  else:\n","    raise ValueError(\n","      'Unknown combination specified {}, use \"mult\", \"sum\", or \"rec\" instead.'.format(comb))\n","\n","  true = [[t] for t in true]\n","  return final_scores, true_index, true, predictions"],"metadata":{"id":"yBSxIvekSI2w","executionInfo":{"status":"ok","timestamp":1666341586385,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"execution_count":11,"outputs":[]},{"cell_type":"markdown","source":["Find anomaly"],"metadata":{"id":"b2Vy_C9kSEO_"}},{"cell_type":"code","source":["\"\"\"\n","Time Series anomaly detection functions.\n","Some of the implementation is inspired by the paper https://arxiv.org/pdf/1802.04431.pdf\n","\"\"\"\n","\n","import numpy as np\n","import pandas as pd\n","from scipy.optimize import fmin\n","\n","\n","def deltas(errors, epsilon, mean, std):\n","  \"\"\"Compute mean and std deltas.\n","  delta_mean = mean(errors) - mean(all errors below epsilon)\n","  delta_std = std(errors) - std(all errors below epsilon)\n","  Args:\n","    errors (ndarray):\n","      Array of errors.\n","    epsilon (ndarray):\n","      Threshold value.\n","    mean (float):\n","      Mean of errors.\n","    std (float):\n","      Standard deviation of errors.\n","  Returns:\n","    float, float:\n","      * delta_mean.\n","      * delta_std.\n","  \"\"\"\n","  below = errors[errors <= epsilon]\n","  if not len(below):\n","    return 0, 0\n","\n","  return mean - below.mean(), std - below.std()\n","\n","\n","def count_above(errors, epsilon):\n","  \"\"\"Count number of errors and continuous sequences above epsilon.\n","  Continuous sequences are counted by shifting and counting the number\n","  of positions where there was a change and the original value was true,\n","  which means that a sequence started at that position.\n","  Args:\n","    errors (ndarray):\n","      Array of errors.\n","    epsilon (ndarray):\n","      Threshold value.\n","  Returns:\n","    int, int:\n","      * Number of errors above epsilon.\n","      * Number of continuous sequences above epsilon.\n","  \"\"\"\n","  above = errors > epsilon\n","  total_above = len(errors[above])\n","\n","  above = pd.Series(above)\n","  shift = above.shift(1)\n","  change = above != shift\n","\n","  total_consecutive = sum(above & change)\n","\n","  return total_above, total_consecutive\n","\n","\n","def z_cost(z, errors, mean, std):\n","  \"\"\"Compute how bad a z value is.\n","  The original formula is::\n","                (delta_mean/mean) + (delta_std/std)\n","      ------------------------------------------------------\n","      number of errors above + (number of sequences above)^2\n","  which computes the \"goodness\" of `z`, meaning that the higher the value\n","  the better the `z`.\n","  In this case, we return this value inverted (we make it negative), to convert\n","  it into a cost function, as later on we will use scipy.fmin to minimize it.\n","  Args:\n","    z (ndarray):\n","      Value for which a cost score is calculated.\n","    errors (ndarray):\n","      Array of errors.\n","    mean (float):\n","      Mean of errors.\n","    std (float):\n","      Standard deviation of errors.\n","  Returns:\n","    float:\n","      Cost of z.\n","  \"\"\"\n","  epsilon = mean + z * std\n","\n","  delta_mean, delta_std = deltas(errors, epsilon, mean, std)\n","  above, consecutive = count_above(errors, epsilon)\n","\n","  numerator = -(delta_mean / mean + delta_std / std)\n","  denominator = above + consecutive ** 2\n","\n","  if denominator == 0:\n","    return np.inf\n","\n","  return numerator / denominator\n","\n","\n","def _find_threshold(errors, z_range):\n","  \"\"\"Find the ideal threshold.\n","  The ideal threshold is the one that minimizes the z_cost function. Scipy.fmin is used\n","  to find the minimum, using the values from z_range as starting points.\n","  Args:\n","    errors (ndarray):\n","      Array of errors.\n","    z_range (list):\n","      List of two values denoting the range out of which the start points for the\n","      scipy.fmin function are chosen.\n","  Returns:\n","    float:\n","      Calculated threshold value.\n","  \"\"\"\n","  mean = errors.mean()\n","  std = errors.std()\n","\n","  min_z, max_z = z_range\n","  best_z = min_z\n","  best_cost = np.inf\n","  for z in range(min_z, max_z):\n","    best = fmin(z_cost, z, args=(errors, mean, std), full_output=True, disp=False) # minimize\n","    z, cost = best[0:2]\n"," \n","    if cost < best_cost:\n","      best_z = z[0]\n","\n","  return mean + best_z * std\n","\n","\n","def _fixed_threshold(errors, k=4):\n","  \"\"\"Calculate the threshold.\n","  The fixed threshold is defined as k standard deviations away from the mean.\n","  Args:\n","    errors (ndarray):\n","      Array of errors.\n","  Returns:\n","    float:\n","      Calculated threshold value.\n","  \"\"\"\n","  mean = errors.mean()\n","  std = errors.std()\n","\n","  return mean + k * std\n","\n","\n","def _find_sequences(errors, epsilon, anomaly_padding):\n","  \"\"\"Find sequences of values that are above epsilon.\n","  This is done following this steps:\n","    * create a boolean mask that indicates which values are above epsilon.\n","    * mark certain range of errors around True values with a True as well.\n","    * shift this mask by one place, filing the empty gap with a False.\n","    * compare the shifted mask with the original one to see if there are changes.\n","    * Consider a sequence start any point which was true and has changed.\n","    * Consider a sequence end any point which was false and has changed.\n","  Args:\n","    errors (ndarray):\n","      Array of errors.\n","    epsilon (float):\n","      Threshold value. All errors above epsilon are considered an anomaly.\n","    anomaly_padding (int):\n","      Number of errors before and after a found anomaly that are added to the\n","      anomalous sequence.\n","  Returns:\n","    ndarray, float:\n","      * Array containing start, end of each found anomalous sequence.\n","      * Maximum error value that was not considered an anomaly.\n","  \"\"\"\n","  above = pd.Series(errors > epsilon)\n","  index_above = np.argwhere(above.values)\n","\n","  for idx in index_above.flatten():\n","    above[max(0, idx - anomaly_padding):min(idx + anomaly_padding + 1, len(above))] = True\n","\n","  shift = above.shift(1).fillna(False)\n","  change = above != shift\n","\n","  if above.all():\n","    max_below = 0\n","  else:\n","    max_below = max(errors[~above])\n","\n","  index = above.index\n","  starts = index[above & change].tolist()\n","  ends = (index[~above & change] - 1).tolist()\n","\n","  if len(ends) == len(starts) - 1:\n","    ends.append(len(above) - 1)\n","\n","  return np.array([starts, ends]).T, max_below\n","\n","\n","def _get_max_errors(errors, sequences, max_below):\n","  \"\"\"Get the maximum error for each anomalous sequence.\n","  Also add a row with the max error which was not considered anomalous.\n","  Table containing a ``max_error`` column with the maximum error of each\n","  sequence and the columns ``start`` and ``stop`` with the corresponding start and stop\n","  indexes, sorted descendingly by the maximum error.\n","  Args:\n","    errors (ndarray):\n","      Array of errors.\n","    sequences (ndarray):\n","      Array containing start, end of anomalous sequences\n","    max_below (float):\n","      Maximum error value that was not considered an anomaly.\n","  Returns:\n","    pandas.DataFrame:\n","      DataFrame object containing columns ``start``, ``stop`` and ``max_error``.\n","  \"\"\"\n","  max_errors = [{\n","    'max_error': max_below,\n","    'start': -1,\n","    'stop': -1\n","  }]\n","\n","  for sequence in sequences:\n","    start, stop = sequence\n","    sequence_errors = errors[start: stop + 1]\n","    max_errors.append({\n","        'start': start,\n","        'stop': stop,\n","        'max_error': max(sequence_errors)\n","    })\n","\n","  max_errors = pd.DataFrame(max_errors).sort_values('max_error', ascending=False)\n","  return max_errors.reset_index(drop=True)\n","\n","\n","def _prune_anomalies(max_errors, min_percent):\n","  \"\"\"Prune anomalies to mitigate false positives.\n","  This is done by following these steps:\n","    * Shift the errors 1 negative step to compare each value with the next one.\n","    * Drop the last row, which we do not want to compare.\n","    * Calculate the percentage increase for each row.\n","    * Find rows which are below ``min_percent``.\n","    * Find the index of the latest of such rows.\n","    * Get the values of all the sequences above that index.\n","  Args:\n","    max_errors (pandas.DataFrame):\n","      DataFrame object containing columns ``start``, ``stop`` and ``max_error``.\n","    min_percent (float):\n","      Percentage of separation the anomalies need to meet between themselves and the\n","      highest non-anomalous error in the window sequence.\n","  Returns:\n","    ndarray:\n","      Array containing start, end, max_error of the pruned anomalies.\n","  \"\"\"\n","  next_error = max_errors['max_error'].shift(-1).iloc[:-1]\n","  max_error = max_errors['max_error'].iloc[:-1]\n","\n","  increase = (max_error - next_error) / max_error\n","  too_small = increase < min_percent\n","\n","  if too_small.all():\n","    last_index = -1\n","  else:\n","    last_index = max_error[~too_small].index[-1]\n","\n","  return max_errors[['start', 'stop', 'max_error']].iloc[0: last_index + 1].values\n","\n","\n","def _compute_scores(pruned_anomalies, errors, threshold, window_start):\n","  \"\"\"Compute the score of the anomalies.\n","  Calculate the score of the anomalies proportional to the maximum error in the sequence\n","  and add window_start timestamp to make the index absolute.\n","  Args:\n","    pruned_anomalies (ndarray):\n","      Array of anomalies containing the start, end and max_error for all anomalies in\n","        the window.\n","      errors (ndarray):\n","        Array of errors.\n","      threshold (float):\n","        Threshold value.\n","      window_start (int):\n","        Index of the first error value in the window.\n","  Returns:\n","    list:\n","      List of anomalies containing start-index, end-index, score for each anomaly.\n","  \"\"\"\n","  anomalies = list()\n","  denominator = errors.mean() + errors.std()\n","\n","  for row in pruned_anomalies:\n","    max_error = row[2]\n","    score = (max_error - threshold) / denominator\n","    anomalies.append([row[0] + window_start, row[1] + window_start, score])\n","\n","  return anomalies\n","\n","\n","def _merge_sequences(sequences):\n","  \"\"\"Merge consecutive and overlapping sequences.\n","  We iterate over a list of start, end, score triples and merge together\n","  overlapping or consecutive sequences.\n","  The score of a merged sequence is the average of the single scores,\n","  weighted by the length of the corresponding sequences.\n","  Args:\n","    sequences (list):\n","      List of anomalies, containing start-index, end-index, score for each anomaly.\n","  Returns:\n","    ndarray:\n","      Array containing start-index, end-index, score for each anomaly after merging.\n","  \"\"\"\n","  if len(sequences) == 0:\n","    return np.array([])\n","\n","  sorted_sequences = sorted(sequences, key=lambda entry: entry[0])\n","  new_sequences = [sorted_sequences[0]]\n","  score = [sorted_sequences[0][2]]\n","  weights = [sorted_sequences[0][1] - sorted_sequences[0][0]]\n","\n","  for sequence in sorted_sequences[1:]:\n","    prev_sequence = new_sequences[-1]\n","\n","    if sequence[0] <= prev_sequence[1] + 1:\n","      score.append(sequence[2])\n","      weights.append(sequence[1] - sequence[0])\n","      weighted_average = np.average(score, weights=weights)\n","      new_sequences[-1] = (prev_sequence[0], max(prev_sequence[1], sequence[1]),\n","                            weighted_average)\n","    else:\n","      score = [sequence[2]]\n","      weights = [sequence[1] - sequence[0]]\n","      new_sequences.append(sequence)\n","\n","  return np.array(new_sequences)\n","\n","\n","def _find_window_sequences(window, z_range, anomaly_padding, min_percent, window_start,\n","                           fixed_threshold):\n","  \"\"\"Find sequences of values that are anomalous.\n","  We first find the threshold for the window, then find all sequences above that threshold.\n","  After that, we get the max errors of the sequences and prune the anomalies. Lastly, the\n","  score of the anomalies is computed.\n","  Args:\n","    window (ndarray):\n","      Array of errors in the window that is analyzed.\n","    z_range (list):\n","      List of two values denoting the range out of which the start points for the\n","      dynamic find_threshold function are chosen.\n","    anomaly_padding (int):\n","      Number of errors before and after a found anomaly that are added to the anomalous\n","      sequence.\n","    min_percent (float):\n","      Percentage of separation the anomalies need to meet between themselves and the\n","      highest non-anomalous error in the window sequence.\n","    window_start (int):\n","      Index of the first error value in the window.\n","    fixed_threshold (bool):\n","      Indicates whether to use fixed threshold or dynamic threshold.\n","  Returns:\n","    ndarray:\n","      Array containing the start-index, end-index, score for each anomalous sequence\n","      that was found in the window.\n","  \"\"\"\n","  if fixed_threshold:\n","    threshold = _fixed_threshold(window)\n","\n","  else:\n","    threshold = _find_threshold(window, z_range)\n","\n","  window_sequences, max_below = _find_sequences(window, threshold, anomaly_padding)\n","  max_errors = _get_max_errors(window, window_sequences, max_below)\n","  pruned_anomalies = _prune_anomalies(max_errors, min_percent)\n","  window_sequences = _compute_scores(pruned_anomalies, window, threshold, window_start)\n","\n","  return window_sequences\n","\n","\n","def find_anomalies(errors, index, z_range=(0, 10), window_size=None, window_size_portion=None,\n","                   window_step_size=None, window_step_size_portion=None, min_percent=0.1,\n","                   anomaly_padding=50, lower_threshold=False, fixed_threshold=None):\n","  \"\"\"Find sequences of error values that are anomalous.\n","  We first define the window of errors, that we want to analyze. We then find the anomalous\n","  sequences in that window and store the start/stop index pairs that correspond to each\n","  sequence, along with its score. Optionally, we can flip the error sequence around the mean\n","  and apply the same procedure, allowing us to find unusually low error sequences.\n","  We then move the window and repeat the procedure.\n","  Lastly, we combine overlapping or consecutive sequences.\n","  Args:\n","    errors (ndarray):\n","      Array of errors.\n","    index (ndarray):\n","      Array of indices of the errors.\n","    z_range (list):\n","      Optional. List of two values denoting the range out of which the start points for\n","      the scipy.fmin function are chosen. If not given, (0, 10) is used.\n","    window_size (int):\n","      Optional. Size of the window for which a threshold is calculated. If not given,\n","      `None` is used, which finds one threshold for the entire sequence of errors.\n","    window_size_portion (float):\n","      Optional. Specify the size of the window to be a portion of the sequence of errors.\n","      If not given, `None` is used, and window size is used as is.\n","    window_step_size (int):\n","      Optional. Number of steps the window is moved before another threshold is\n","      calculated for the new window.\n","    window_step_size_portion (float):\n","      Optional. Specify the number of steps to be a portion of the window size. If not given,\n","      `None` is used, and window step size is used as is.\n","    min_percent (float):\n","      Optional. Percentage of separation the anomalies need to meet between themselves and\n","      the highest non-anomalous error in the window sequence. It nof given, 0.1 is used.\n","    anomaly_padding (int):\n","      Optional. Number of errors before and after a found anomaly that are added to the\n","      anomalous sequence. If not given, 50 is used.\n","    lower_threshold (bool):\n","      Optional. Indicates whether to apply a lower threshold to find unusually low errors.\n","      If not given, `False` is used.\n","    fixed_threshold (bool):\n","      Optional. Indicates whether to use fixed threshold or dynamic threshold. If not\n","      given, `False` is used.\n","  Returns:\n","    ndarray:\n","      Array containing start-index, end-index, score for each anomalous sequence that\n","      was found.\n","  \"\"\"\n","  window_size = window_size or len(errors)\n","  if window_size_portion:\n","    window_size = np.ceil(len(errors) * window_size_portion).astype('int')\n","\n","  window_step_size = window_step_size or window_size\n","  if window_step_size_portion:\n","    window_step_size = np.ceil(window_size * window_step_size_portion).astype('int')\n","\n","  window_start = 0\n","  window_end = 0\n","  sequences = list()\n","\n","  while window_end < len(errors):\n","    window_end = window_start + window_size\n","    window = errors[window_start:window_end]\n","    window_sequences = _find_window_sequences(window, z_range, anomaly_padding, min_percent,\n","                                              window_start, fixed_threshold)\n","    sequences.extend(window_sequences)\n","\n","    if lower_threshold:\n","      # Flip errors sequence around mean\n","      mean = window.mean()\n","      inverted_window = mean - (window - mean)\n","      inverted_window_sequences = _find_window_sequences(inverted_window, z_range,\n","                                                          anomaly_padding, min_percent,\n","                                                          window_start, fixed_threshold)\n","      sequences.extend(inverted_window_sequences)\n","\n","    window_start = window_start + window_step_size\n","\n","  sequences = _merge_sequences(sequences)\n","\n","  anomalies = list()\n","\n","  for start, stop, score in sequences:\n","    anomalies.append([index[int(start)], index[int(stop)], score])\n","\n","  return np.asarray(anomalies)"],"metadata":{"id":"rYb6rsuUSD0A","executionInfo":{"status":"ok","timestamp":1666341586385,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"execution_count":12,"outputs":[]},{"cell_type":"code","source":["def ad_test(test_loader, encoder, decoder, critic_x):\n","    reconstruction_error = list()\n","    critic_score = list()\n","    y_true = list()\n","\n","    for batch, sample in enumerate(test_loader):\n","        # reconstructed_signal = decoder(encoder(sample['signal']))\n","        reconstructed_signal = decoder(encoder(sample))\n","        reconstructed_signal = torch.squeeze(reconstructed_signal)\n","        \n","        for i in range(0, 64):\n","            print(i)\n","            x_ = reconstructed_signal[i].detach().numpy()\n","            # x = sample['signal'][i].numpy()\n","            x = sample[i].numpy()\n","            # y_true.append(int(sample['anomaly'][i].detach()))\n","            y_true.append(int(sample[i].detach()))######\n","            reconstruction_error.append(dtw_reconstruction_error(x, x_))\n","        # critic_score.extend(torch.squeeze(critic_x(sample['signal'])).detach().numpy())\n","        critic_score.extend(torch.squeeze(critic_x(sample)).detach().numpy())\n","\n","    reconstruction_error = stats.zscore(reconstruction_error)\n","    critic_score = stats.zscore(critic_score)\n","    anomaly_score = reconstruction_error * critic_score\n","    y_predict = detect_anomaly(anomaly_score)\n","    y_predict = prune_false_positive(y_predict, anomaly_score, change_threshold=0.1)\n","    print(y_predict.shape) # 896,\n","    print(y_predict)\n","    raise\n","    find_scores(y_true, y_predict)\n","\n","#Other error metrics - point wise difference, Area difference.\n","def dtw_reconstruction_error(x, x_):\n","    n, m = x.shape[0], x_.shape[0]\n","    dtw_matrix = np.zeros((n+1, m+1))\n","    for i in range(n+1):\n","        for j in range(m+1):\n","            dtw_matrix[i, j] = np.inf\n","    dtw_matrix[0, 0] = 0\n","\n","    for i in range(1, n+1):\n","        for j in range(1, m+1):\n","            cost = abs(x[i-1] - x_[j-1])\n","            # take last min from a square box\n","            last_min = np.min([dtw_matrix[i-1, j], dtw_matrix[i, j-1], dtw_matrix[i-1, j-1]])\n","            dtw_matrix[i, j] = cost + last_min\n","    return dtw_matrix[n][m]\n","\n","def unroll_signal(x):\n","    x = np.array(x).reshape(100)\n","    return np.median(x)\n","\n","def prune_false_positive(is_anomaly, anomaly_score, change_threshold):\n","  #The model might detect a high number of false positives.\n","  #In such a scenario, pruning of the false positive is suggested.\n","  #Method used is as described in the Section 5, part D Identifying Anomalous\n","  #Sequence, sub-part - Mitigating False positives\n","  #TODO code optimization\n","  seq_details = []\n","  delete_sequence = 0\n","  start_position = 0\n","  end_position = 0\n","  max_seq_element = anomaly_score[0]\n","  for i in range(1, len(is_anomaly)):\n","    if i+1 == len(is_anomaly):\n","      seq_details.append([start_position, i, max_seq_element, delete_sequence])\n","    elif is_anomaly[i] == 1 and is_anomaly[i+1] == 0:\n","      end_position = i\n","      seq_details.append([start_position, end_position, max_seq_element, delete_sequence])\n","    elif is_anomaly[i] == 1 and is_anomaly[i-1] == 0:\n","        start_position = i\n","        max_seq_element = anomaly_score[i]\n","    if is_anomaly[i] == 1 and is_anomaly[i-1] == 1 and anomaly_score[i] > max_seq_element:\n","        max_seq_element = anomaly_score[i]\n","\n","  max_elements = list()\n","  for i in range(0, len(seq_details)):\n","      max_elements.append(seq_details[i][2])\n","\n","  max_elements.sort(reverse=True)\n","  max_elements = np.array(max_elements)\n","  change_percent = abs(max_elements[1:] - max_elements[:-1]) / max_elements[1:]\n","\n","  #Appending 0 for the 1 st element which is not change percent\n","  delete_seq = np.append(np.array([0]), change_percent < change_threshold)\n","\n","  #Mapping max element and seq details\n","  for i, max_elt in enumerate(max_elements):\n","      for j in range(0, len(seq_details)):\n","          if seq_details[j][2] == max_elt:\n","              seq_details[j][3] = delete_seq[i]\n","\n","  for seq in seq_details:\n","      if seq[3] == 1: #Delete sequence\n","          is_anomaly[seq[0]:seq[1]+1] = [0] * (seq[1] - seq[0] + 1)\n","\n","  return is_anomaly\n","\n","def detect_anomaly(anomaly_score):\n","  window_size = len(anomaly_score) // 3\n","  step_size = len(anomaly_score) // (3 * 10)\n","\n","  is_anomaly = np.zeros(len(anomaly_score))\n","\n","  for i in range(0, len(anomaly_score) - window_size, step_size):\n","    window_elts = anomaly_score[i:i+window_size]\n","    window_mean = np.mean(window_elts)\n","    window_std = np.std(window_elts)\n","\n","    for j, elt in enumerate(window_elts):\n","      if (window_mean - 3 * window_std) < elt < (window_mean + 3 * window_std):\n","        is_anomaly[i + j] = 0\n","      else:\n","        is_anomaly[i + j] = 1\n","\n","  return is_anomaly\n","\n","def find_scores(y_true, y_predict):\n","  tp = tn = fp = fn = 0\n","\n","  for i in range(0, len(y_true)):\n","    if y_true[i] == 1 and y_predict[i] == 1:\n","      tp += 1\n","    elif y_true[i] == 1 and y_predict[i] == 0:\n","      fn += 1\n","    elif y_true[i] == 0 and y_predict[i] == 0:\n","      tn += 1\n","    elif y_true[i] == 0 and y_predict[i] == 1:\n","      fp += 1\n","\n","  print ('Accuracy {:.2f}'.format((tp + tn)/(len(y_true))))\n","  precision = tp / (tp + fp)\n","  recall = tp / (tp + fn)\n","  print ('Precision {:.2f}'.format(precision))\n","  print ('Recall {:.2f}'.format(recall))\n","  print ('F1 Score {:.2f}'.format(2 * precision * recall / (precision + recall)))"],"metadata":{"id":"PuJY1NGfLeZ3","executionInfo":{"status":"ok","timestamp":1666341586385,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"execution_count":13,"outputs":[]},{"cell_type":"markdown","source":["## Model"],"metadata":{"id":"bUG1D9-CSqQy"}},{"cell_type":"code","execution_count":14,"metadata":{"id":"hNPCXH550HNG","executionInfo":{"status":"ok","timestamp":1666341586385,"user_tz":-540,"elapsed":2,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["import os\n","import logging\n","import numpy as np\n","\n","import torch\n","import torch.nn as nn\n","import torch.optim as optim\n","from torch.autograd import Variable\n","from torch.utils.data import Dataset, DataLoader\n","\n","class Encoder(nn.Module):\n","\n","  def __init__(self, encoder_path, signal_shape=100):\n","    super(Encoder, self).__init__()\n","    self.signal_shape = signal_shape\n","    self.lstm = nn.LSTM(input_size=self.signal_shape, hidden_size=20, num_layers=1, bidirectional=True)\n","    self.dense = nn.Linear(in_features=40, out_features=20)\n","    self.encoder_path = encoder_path\n","\n","  def forward(self, x):\n","    x = x.reshape(1, 64, self.signal_shape).float()\n","    x, (hn, cn) = self.lstm(x)\n","    x = self.dense(x)\n","    return (x)\n","\n","class Decoder(nn.Module):\n","  def __init__(self, decoder_path, signal_shape=100):\n","    super(Decoder, self).__init__()\n","    self.signal_shape = signal_shape\n","    self.lstm = nn.LSTM(input_size=20, hidden_size=64, num_layers=2, bidirectional=True)\n","    self.dense = nn.Linear(in_features=128, out_features=self.signal_shape)\n","    self.decoder_path = decoder_path\n","\n","  def forward(self, x):\n","    x, (hn, cn) = self.lstm(x)\n","    x = self.dense(x)\n","    return (x)\n","\n","class CriticX(nn.Module):\n","  def __init__(self, critic_x_path, signal_shape=100):\n","    super(CriticX, self).__init__()\n","    self.signal_shape = signal_shape\n","    self.dense1 = nn.Linear(in_features=self.signal_shape, out_features=20)\n","    self.dense2 = nn.Linear(in_features=20, out_features=1)\n","    self.critic_x_path = critic_x_path\n","\n","  def forward(self, x):\n","    x = x.view(1, 64, self.signal_shape).float()\n","    # x = x.view(1, x.shape[1], self.signal_shape).float()\n","    x = self.dense1(x)\n","    x = self.dense2(x)\n","    return (x)\n","\n","class CriticZ(nn.Module):\n","  def __init__(self, critic_z_path):\n","    super(CriticZ, self).__init__()\n","    self.dense1 = nn.Linear(in_features=20, out_features=1)\n","    self.critic_z_path = critic_z_path\n","\n","  def forward(self, x):\n","    x = self.dense1(x)\n","    return (x)\n","\n","def unroll_signal(self, x):\n","  x = np.array(x).reshape(100)\n","  return np.median(x)\n","\n","def test(self):\n","  \"\"\"\n","  Returns a dataframe with original value, reconstructed value, reconstruction error, critic score\n","  \"\"\"\n","  df = self.test_dataset.copy()\n","  X_ = list()\n","\n","  RE = list()  #Reconstruction error\n","  CS = list()  #Critic score\n","\n","  for i in range(0, df.shape[0]):\n","    x = df.rolled_signal[i]\n","    x = tf.reshape(x, (1, 100, 1))\n","    z = encoder(x)\n","    z = tf.expand_dims(z, axis=2)\n","    x_ = decoder(z)\n","\n","    re = dtw_reconstruction_error(tf.squeeze(x_).numpy(), tf.squeeze(x).numpy()) #reconstruction error\n","    cs = critic_x(x)\n","    cs = tf.squeeze(cs).numpy()\n","    RE.append(re)\n","    CS.append(cs)\n","\n","    x_ = unroll_signal(x_)\n","\n","    X_.append(x_)\n","\n","  df['generated_signals'] = X_\n","\n","  return df"]},{"cell_type":"code","source":["'''\n","https://github.com/arunppsg/TadGAN\n","'''\n","def critic_x_iteration(sample):\n","  optim_cx.zero_grad()\n","  \n","  # x = sample['signal'].view(1, batch_size, signal_shape)\n","  x = sample.view(1, sample.shape[0], signal_shape)\n","  valid_x = critic_x(x)\n","  valid_x = torch.squeeze(valid_x)\n","  critic_score_valid_x = torch.mean(torch.ones(valid_x.shape) * valid_x) # Wasserstein Loss\n","\n","  #The sampled z are the anomalous points - points deviating from actual distribution of z (obtained through encoding x)\n","  z = torch.empty(1, batch_size, latent_space_dim).uniform_(0, 1)\n","  x_ = decoder(z)\n","  fake_x = critic_x(x_)\n","  fake_x = torch.squeeze(fake_x)\n","  critic_score_fake_x = torch.mean(torch.ones(fake_x.shape) * fake_x)  #Wasserstein Loss\n","\n","  alpha = torch.rand(x.shape)\n","  ix = Variable(alpha * x + (1 - alpha) * x_) #Random Weighted Average\n","  ix.requires_grad_(True)\n","  v_ix = critic_x(ix)\n","  v_ix.mean().backward()\n","  gradients = ix.grad\n","  #Gradient Penalty Loss\n","  gp_loss = torch.sqrt(torch.sum(torch.square(gradients).view(-1)))\n","\n","  #Critic has to maximize Cx(Valid X) - Cx(Fake X).\n","  #Maximizing the above is same as minimizing the negative.\n","  wl = critic_score_fake_x - critic_score_valid_x\n","  loss = wl + gp_loss\n","  loss.backward()\n","  optim_cx.step()\n","\n","  return loss\n","\n","def critic_z_iteration(sample):\n","  optim_cz.zero_grad()\n","\n","  # x = sample['signal'].view(1, batch_size, signal_shape)\n","  x = sample.view(1, batch_size, signal_shape)\n","  z = encoder(x)\n","  valid_z = critic_z(z)\n","  valid_z = torch.squeeze(valid_z)\n","  critic_score_valid_z = torch.mean(torch.ones(valid_z.shape) * valid_z)\n","\n","  z_ = torch.empty(1, batch_size, latent_space_dim).uniform_(0, 1)\n","  fake_z = critic_z(z_)\n","  fake_z = torch.squeeze(fake_z)\n","  critic_score_fake_z = torch.mean(torch.ones(fake_z.shape) * fake_z) #Wasserstein Loss\n","\n","  wl = critic_score_fake_z - critic_score_valid_z\n","\n","  alpha = torch.rand(z.shape)\n","  iz = Variable(alpha * z + (1 - alpha) * z_) #Random Weighted Average\n","  iz.requires_grad_(True)\n","  v_iz = critic_z(iz)\n","  v_iz.mean().backward()\n","  gradients = iz.grad\n","  gp_loss = torch.sqrt(torch.sum(torch.square(gradients).view(-1)))\n","\n","  loss = wl + gp_loss\n","  loss.backward()\n","  optim_cz.step()\n","\n","  return loss\n","\n","def encoder_iteration(sample):\n","  optim_enc.zero_grad()\n","  # x = sample['signal'].view(1, batch_size, signal_shape)\n","  x = sample.view(1, batch_size, signal_shape)\n","  valid_x = critic_x(x)\n","  valid_x = torch.squeeze(valid_x)\n","  critic_score_valid_x = torch.mean(torch.ones(valid_x.shape) * valid_x) #Wasserstein Loss\n","\n","  z = torch.empty(1, batch_size, latent_space_dim).uniform_(0, 1)\n","  x_ = decoder(z)\n","  fake_x = critic_x(x_)\n","  fake_x = torch.squeeze(fake_x)\n","  critic_score_fake_x = torch.mean(torch.ones(fake_x.shape) * fake_x)\n","\n","  enc_z = encoder(x)\n","  gen_x = decoder(enc_z)\n","\n","  mse = mse_loss(x.float(), gen_x.float())\n","  loss_enc = mse + critic_score_valid_x - critic_score_fake_x\n","  loss_enc.backward(retain_graph=True)\n","  optim_enc.step()\n","\n","  return loss_enc\n","\n","def decoder_iteration(sample):\n","  optim_dec.zero_grad()\n","\n","  # x = sample['signal'].view(1, batch_size, signal_shape)\n","  x = sample.view(1, batch_size, signal_shape)\n","  z = encoder(x)\n","  valid_z = critic_z(z)\n","  valid_z = torch.squeeze(valid_z)\n","  critic_score_valid_z = torch.mean(torch.ones(valid_z.shape) * valid_z)\n","\n","  z_ = torch.empty(1, batch_size, latent_space_dim).uniform_(0, 1)\n","  fake_z = critic_z(z_)\n","  fake_z = torch.squeeze(fake_z)\n","  critic_score_fake_z = torch.mean(torch.ones(fake_z.shape) * fake_z)\n","\n","  enc_z = encoder(x)\n","  gen_x = decoder(enc_z)\n","\n","  mse = mse_loss(x.float(), gen_x.float())\n","  loss_dec = mse + critic_score_valid_z - critic_score_fake_z\n","  loss_dec.backward(retain_graph=True)\n","  optim_dec.step()\n","\n","  return loss_dec\n","\n","\n","def train(n_epochs=2000):\n","  logging.debug('Starting training')\n","  cx_epoch_loss = list()\n","  cz_epoch_loss = list()\n","  encoder_epoch_loss = list()\n","  decoder_epoch_loss = list()\n","\n","  for epoch in range(n_epochs):\n","    logging.debug('Epoch {}'.format(epoch))\n","    n_critics = 5\n","\n","    cx_nc_loss = list()\n","    cz_nc_loss = list()\n","\n","    for i in range(n_critics):\n","      cx_loss = list()\n","      cz_loss = list()\n","\n","      for batch, sample in enumerate(train_loader):\n","        loss = critic_x_iteration(sample)\n","        cx_loss.append(loss)\n","\n","        loss = critic_z_iteration(sample)\n","        cz_loss.append(loss)\n","\n","      cx_nc_loss.append(torch.mean(torch.tensor(cx_loss)))\n","      cz_nc_loss.append(torch.mean(torch.tensor(cz_loss)))\n","    \n","    # print(f\"{epoch}epoch loss : {torch.mean(torch.tensor(cx_nc_loss))}\")\n","    \n","    logging.debug('Critic training done in epoch {}'.format(epoch))\n","    encoder_loss = list()\n","    decoder_loss = list()\n","\n","    for batch, sample in enumerate(train_loader):\n","      enc_loss = encoder_iteration(sample)\n","      dec_loss = decoder_iteration(sample)\n","      encoder_loss.append(enc_loss)\n","      decoder_loss.append(dec_loss)\n","\n","      wandb.log({\n","                \"enc_loss\": enc_loss,\n","                \"dec_loss\": dec_loss,\n","                \"encoder_loss\" : encoder_loss,\n","                \"decoder_loss\" : decoder_loss\n","            })\n","\n","    cx_epoch_loss.append(torch.mean(torch.tensor(cx_nc_loss)))\n","    cz_epoch_loss.append(torch.mean(torch.tensor(cz_nc_loss)))\n","    encoder_epoch_loss.append(torch.mean(torch.tensor(encoder_loss)))\n","    decoder_epoch_loss.append(torch.mean(torch.tensor(decoder_loss)))\n","    logging.debug('Encoder decoder training done in epoch {}'.format(epoch))\n","    logging.debug('critic x loss {:.3f} critic z loss {:.3f} \\nencoder loss {:.3f} decoder loss {:.3f}\\n'.format(cx_epoch_loss[-1], cz_epoch_loss[-1], encoder_epoch_loss[-1], decoder_epoch_loss[-1]))\n","\n","    if epoch % 10 == 0:\n","      torch.save(encoder.state_dict(), encoder.encoder_path)\n","      torch.save(decoder.state_dict(), decoder.decoder_path)\n","      torch.save(critic_x.state_dict(), critic_x.critic_x_path)\n","      torch.save(critic_z.state_dict(), critic_z.critic_z_path)\n"],"metadata":{"id":"Z4EblAP8W_A9","executionInfo":{"status":"ok","timestamp":1666341586385,"user_tz":-540,"elapsed":2,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"execution_count":15,"outputs":[]},{"cell_type":"markdown","source":["## Main"],"metadata":{"id":"9TSMXPMBStSQ"}},{"cell_type":"code","source":["# dataset = pd.read_csv('exchange-2_cpc_results.csv')\n","# #Splitting intro train and test\n","# #TODO could be done in a more pythonic way\n","# train_len = int(0.7 * dataset.shape[0])\n","# dataset[0:train_len].to_csv('train_dataset.csv', index=False)\n","# dataset[train_len:].to_csv('test_dataset.csv', index=False)\n","\n","# train_dataset = SignalDataset(path='train_dataset.csv')\n","# test_dataset = SignalDataset(path='test_dataset.csv')\n","\n","config = easydict.EasyDict({\n","    \"num_epochs\" : 20, #500\n","    \"batch_size\" : 64, #16 \n","    \"mode\" : 'train',\n","    # \"mode\" : \"test\",\n","    \"lr\" : 5e-3, \n","    \"wd\" : None,\n","    \"window_size\" : 1000,\n","    \"stride\" : 250,\n","    \"threshold\" : 0.3, # 0.3이나 0.2로 하기\n","    \"seed\" : 10041004,\n","    \"device\" : torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu'),\n","    \"small_window\" : 9,\n","    \"small_stride\" : 5,\n","    \"latent\" : 20,\n","    \"scaler\" : \"minmax\"\n","})\n","\n","batch_size = 64\n","lr = 1e-3 #1e-6\n","signal_shape = 1000 #100\n","latent_space_dim = 20\n","\n","#---# wandb #---#\n","wandb.init(project=f\"TadGAN\", \n","           entity=\"sohyun\", \n","           name=f\"{config.num_epochs}_{config.window_size}_{config.stride}_{config.batch_size}\")\n","\n","\n","#---# Dataset & Dataloader #---#\n","train_dataset = MyDataset(config, mode=\"train\")\n","train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=False, drop_last=True) # drop_last=True\n","\n","val_dataset = MyDataset(config, mode=\"val\")\n","val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False, drop_last=True)\n","\n","test_dataset = MyDataset(config, mode=\"test\")\n","test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False, drop_last=True) # drop_last=True\n","\n","logging.info('Number of train datapoints is {}'.format(len(train_dataset)))\n","logging.info('Number of samples in train dataset {}'.format(len(train_dataset)))\n","\n","encoder_path = save_path + '/model_save/encoder.pt'\n","decoder_path = save_path + '/model_save/decoder.pt'\n","critic_x_path = save_path + '/model_save/critic_x.pt'\n","critic_z_path = save_path + '/model_save/critic_z.pt'\n","\n","encoder = Encoder(encoder_path, signal_shape)\n","decoder = Decoder(decoder_path, signal_shape)\n","critic_x = CriticX(critic_x_path, signal_shape)\n","critic_z = CriticZ(critic_z_path)\n","\n","mse_loss = torch.nn.MSELoss()\n","\n","optim_enc = optim.Adam(encoder.parameters(), lr=lr, betas=(0.5, 0.999))\n","optim_dec = optim.Adam(decoder.parameters(), lr=lr, betas=(0.5, 0.999))\n","optim_cx = optim.Adam(critic_x.parameters(), lr=lr, betas=(0.5, 0.999))\n","optim_cz = optim.Adam(critic_z.parameters(), lr=lr, betas=(0.5, 0.999))\n","\n","train(n_epochs=config.num_epochs)\n","\n","#---# prediction #---#\n","preds = []\n","critic_score = []\n","for batch, sample in enumerate(test_loader):\n","  pred = decoder(encoder(sample))\n","  critic = critic_x(sample).detach().numpy() # [1,64,1]\n","\n","  preds.append(pred.reshape(64,1000))\n","  critic_score.extend(critic.reshape(64))\n","\n","predictions = torch.cat(preds)\n","\n","#---# calculate error range #---#\n","final_scores, true_index, true, predictions = score_anomalies(y = test_dataset.x_test[:len(predictions)],\n","                                                              y_hat = predictions.cpu().detach().numpy(),\n","                                                              critic = critic_score,\n","                                                              index=np.array(range(len(predictions))))\n","\n","error_range = find_anomalies(final_scores, index=range(len(final_scores)), anomaly_padding=3, window_size_portion=0.33, window_step_size_portion=0.1)\n","\n","print(\"=== error_range ===\\n\", error_range)\n","prediction = pd.DataFrame(0, index=range(0, len(test_dataset.scaled_test)), columns={'Fu'}) # 빈 행렬\n","for i in error_range:\n","  start = int(i[0])\n","  end = int(i[1])\n","  prediction[start:end] = 1\n","\n","true_label = get_true_label(test_dataset)\n","anomaly_value = get_anomaly_time(test_dataset.scaled_test, \n","                                 prediction['Fu'].values.tolist())\n","drawing(config, anomaly_value, pd.DataFrame(test_dataset.scaled_test))\n","recall, precision, accuracy = calculate(pd.DataFrame(true_label), \n","                                        pd.DataFrame(anomaly_value))\n","fprs, tprs, thresholds = calculate2(true_label, anomaly_value)\n","print(f'recall : {recall}, precision : {precision}, accuracy : {accuracy}')\n","# ad_test(test_loader, encoder, decoder, critic_x)"],"metadata":{"id":"BSklUucaYRHF","colab":{"base_uri":"https://localhost:8080/","height":885},"executionInfo":{"status":"error","timestamp":1666341713192,"user_tz":-540,"elapsed":89572,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}},"outputId":"9066a63b-2d63-4291-c2b4-4562b1a38e4b"},"execution_count":18,"outputs":[{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.HTML object>"],"text/html":["Tracking run with wandb version 0.13.4"]},"metadata":{}},{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.HTML object>"],"text/html":["Run data is saved locally in <code>/content/drive/.shortcut-targets-by-id/1j1N0u5t0l99N_wfSd5UZvnhugzn5g_NC/TimeSeriesAnomaly/data/modify/wandb/run-20221021_084023-lop2976z</code>"]},"metadata":{}},{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.HTML object>"],"text/html":["Syncing run <strong><a href=\"https://wandb.ai/sohyun/TadGAN/runs/lop2976z\" target=\"_blank\">20_1000_250_64</a></strong> to <a href=\"https://wandb.ai/sohyun/TadGAN\" target=\"_blank\">Weights & Biases</a> (<a href=\"https://wandb.me/run\" target=\"_blank\">docs</a>)<br/>"]},"metadata":{}},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.7/dist-packages/scipy/optimize/optimize.py:761: RuntimeWarning: invalid value encountered in subtract\n","  np.max(np.abs(fsim[0] - fsim[1:])) <= fatol):\n"]},{"output_type":"stream","name":"stdout","text":["=== error_range ===\n"," [[7.00000000e+00 1.70000000e+01 4.45813527e-01]\n"," [2.49000000e+02 2.62000000e+02 5.49616679e-01]\n"," [3.88000000e+02 3.98000000e+02 3.56872896e-01]\n"," [4.01000000e+02 4.23000000e+02 5.77895646e-01]\n"," [5.95000000e+02 6.08000000e+02 2.74339948e-01]\n"," [6.90000000e+02 6.97000000e+02 4.76872076e-02]\n"," [8.48000000e+02 8.56000000e+02 7.26208515e-02]]\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 2160x360 with 1 Axes>"],"image/png":"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\n"},"metadata":{"needs_background":"light"}},{"output_type":"error","ename":"ValueError","evalue":"ignored","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)","\u001b[0;32m<ipython-input-18-414127d87560>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m    103\u001b[0m recall, precision, accuracy = calculate(pd.DataFrame(true_label), \n\u001b[1;32m    104\u001b[0m                                         pd.DataFrame(anomaly_value))\n\u001b[0;32m--> 105\u001b[0;31m \u001b[0mfprs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtprs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mthresholds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcalculate2\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtrue_label\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0manomaly_value\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    106\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34mf'recall : {recall}, precision : {precision}, accuracy : {accuracy}'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    107\u001b[0m \u001b[0;31m# ad_test(test_loader, encoder, decoder, critic_x)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m<ipython-input-10-615c943a9c05>\u001b[0m in \u001b[0;36mcalculate2\u001b[0;34m(true_list, pred_list)\u001b[0m\n\u001b[1;32m     63\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     64\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mcalculate2\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtrue_list\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpred_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 65\u001b[0;31m   \u001b[0mfprs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtprs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mthresholds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mroc_curve\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtrue_list\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpred_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     66\u001b[0m   \u001b[0;32mreturn\u001b[0m \u001b[0mfprs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtprs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mthresholds\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     67\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/metrics/_ranking.py\u001b[0m in \u001b[0;36mroc_curve\u001b[0;34m(y_true, y_score, pos_label, sample_weight, drop_intermediate)\u001b[0m\n\u001b[1;32m    961\u001b[0m     \"\"\"\n\u001b[1;32m    962\u001b[0m     fps, tps, thresholds = _binary_clf_curve(\n\u001b[0;32m--> 963\u001b[0;31m         \u001b[0my_true\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_score\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpos_label\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mpos_label\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msample_weight\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0msample_weight\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    964\u001b[0m     )\n\u001b[1;32m    965\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/metrics/_ranking.py\u001b[0m in \u001b[0;36m_binary_clf_curve\u001b[0;34m(y_true, y_score, pos_label, sample_weight)\u001b[0m\n\u001b[1;32m    735\u001b[0m     \u001b[0my_score\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcolumn_or_1d\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my_score\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    736\u001b[0m     \u001b[0massert_all_finite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my_true\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 737\u001b[0;31m     \u001b[0massert_all_finite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my_score\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    738\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    739\u001b[0m     \u001b[0;31m# Filter out zero-weighted samples, as they should not impact the result\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/utils/validation.py\u001b[0m in \u001b[0;36massert_all_finite\u001b[0;34m(X, allow_nan)\u001b[0m\n\u001b[1;32m    132\u001b[0m     \u001b[0mallow_nan\u001b[0m \u001b[0;34m:\u001b[0m \u001b[0mbool\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdefault\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    133\u001b[0m     \"\"\"\n\u001b[0;32m--> 134\u001b[0;31m     \u001b[0m_assert_all_finite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0msp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0missparse\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mallow_nan\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    135\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    136\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/utils/validation.py\u001b[0m in \u001b[0;36m_assert_all_finite\u001b[0;34m(X, allow_nan, msg_dtype)\u001b[0m\n\u001b[1;32m    114\u001b[0m             raise ValueError(\n\u001b[1;32m    115\u001b[0m                 msg_err.format(\n\u001b[0;32m--> 116\u001b[0;31m                     \u001b[0mtype_err\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmsg_dtype\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mmsg_dtype\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    117\u001b[0m                 )\n\u001b[1;32m    118\u001b[0m             )\n","\u001b[0;31mValueError\u001b[0m: Input contains NaN, infinity or a value too large for dtype('float32')."]},{"output_type":"display_data","data":{"text/plain":["<Figure size 432x288 with 0 Axes>"]},"metadata":{}}]},{"cell_type":"code","source":["raise"],"metadata":{"id":"W1JHp1LF7A4Z","executionInfo":{"status":"aborted","timestamp":1666341586944,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["anomaly_value[690:800]"],"metadata":{"id":"rLFpLrk93pdg","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":4,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"i2jd8bWocNzA","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":4,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["anomaly_value"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ud1EwYw4cNvj","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":4,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["t = anomaly_value\n","t[np.isnan(t)] = 0\n","t[t!=0] = "]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jQoQOOtBhcXl","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":4,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":["t[t!=0]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"OK3w5Cr8v5dJ","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":4,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vA2G0vWmv5Wo","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"gY-C_kr7v5TQ","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"XbMQF9uNv5Oz","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ubS_Nsgqv5Ke","executionInfo":{"status":"aborted","timestamp":1666341586945,"user_tz":-540,"elapsed":3,"user":{"displayName":"아이덴티파이ai","userId":"09195867153538576050"}}},"outputs":[],"source":[]}],"metadata":{"colab":{"collapsed_sections":["H3eN0oaUUbB-","zjoJxI3iylhf","pFXdkFGgSg5M"],"provenance":[],"mount_file_id":"1iUI5TdFKacTS2eemlzXXKidMN4qhQqHU","authorship_tag":"ABX9TyOi0TdgroY/JOtFisj2m0lb"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"},"accelerator":"GPU","gpuClass":"standard"},"nbformat":4,"nbformat_minor":0}